<html>
	<head>
	</head>
	<body>
		<h2> Task 1 </h2>
		<b>Walk through how you rasterize triangles in your own words.</b>
		
		<p> Simply put, rasterizing a triangle is the process of finding the lines and points that make up the triangle and then testing whether each pixel is inside the triangle or not. If it is, then we render it and if it is not then we leave it alone.</p>
	
		<b>Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle. </b>
		
		<p> My algorithm is based off of the point in triangle test from the lecture 2 slides. The boundary box is created by taking the points and finding the min and max coodinartes for the 2 for loops (x & y). This helps avoid checking every pixel on the screen, which would make it slower. Then after all of the checks are done, I call fill_pixel() if the pixel passed the test.</p>
		
		
		<b>Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</b>
		<img src="./screenshot_2-13_15-9-41.png">
		
		<h2> Task 2 </h2>
		
		<b> Walk through your supersampling algorithm and data structures. Why is supersampling useful? What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.</b>
		<p> My algorithm modifies the rasterize_triangle from task 1 by adding in 2 extra for loops to sample more pixels based on the sample rate (for ex. 2x2 would have pixels at offsets of 1/4 and 3/4). The offets for each sample rate are calculated based on the index and the base fraction of 0.5 / sqrt(sample_rate). The same point in triangle test occurs with each point and they are added to the sample buffer (which has been resized to be width * height * sample_rate) if they pass. Then, once all the subpixels are sampled, I went into resolve_to_framebuffer to average the color by adding up all of the subpixel colors and then dividing r,g,b by sqrt(sample_rate). rgb_framebuffer_target is then set to each color channel (current index + 0 is r, current index + 1 is g, and current index + 2 is b). Supersampling is useful for when you want to blur the edges of an image more so that it looks less jagged (i.e. helps get rid of jaggies). Through supersampling, I can average out the pixels' colors into something that looks more smooth. Instead of each pixel only being able to be one solid color, they can be a blend of multiple colors, which makes the edges stand out less.  </p>		
		
		<b> Show png screenshots of basic/test4.svg with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.</b>
		<p> sample rate = 1 - normal sampling, have  a lot of jaggies because there is no blending </p>
		<img src="./screenshot_2-14_14-20-31.png">
		<p> sample rate = 4 - the edges are more straight here because sampling the subpixels</p>
		<img src="./screenshot_2-14_14-20-37.png">
		<p> sample rate = 16 - the edges are blurred a little bit, you can see that the color is a mix of the magenta and white background.</p>
		<img src="./screenshot_2-14_14-20-42.png">
		
		<h2> Task 3</h2>
		
		<b> Create an updated version of svg/transforms/robot.svg with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your svg file as my_robot.svg in your docs/ directory and show a png screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words. </b>
		
	</body>
</html>
