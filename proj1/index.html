<html>
	<head>
	</head>
	<body>
		<h2> Task 1 </h2>
		<b>Walk through how you rasterize triangles in your own words.</b>
		<p> Simply put, rasterizing a triangle is the process of finding the lines and points that make up the triangle and then testing whether each pixel is inside the triangle or not. If it is, then we render it and if it is not then we leave it alone.</p>
		
		<b>Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle. </b>
		
		<p> My algorithm is based off of the point in triangle test from the lecture 2 slides. The boundary box is created by taking the points and finding the min and max coodinartes for the 2 for loops (x & y). This helps avoid checking every pixel on the screen, which would make it slower. Then after all of the checks are done, I call fill_pixel() if the pixel passed the test.</p>
		
		
		<b>Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</b>
		<img src="./screenshot_2-13_15-9-41.png">
		
		<h2> Task 2 </h2>
		
		<b> Walk through your supersampling algorithm and data structures. Why is supersampling useful? What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.</b>
		
		
		
		<b> Show png screenshots of basic/test4.svg with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.</b>
		
	</body>
</html>
