<html>
	<head>
		<link rel="stylesheet" href="style.css">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Dosis:wght@300&family=Righteous&display=swap" rel="stylesheet">
	</head>
	<body>
		<!-- ##################TASK 1##################-->

		<h2> Task 1 </h2>
		
		<p><b> Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.</b></p>
		<p> de Casteljau's algorithm is a recursive algorithm that repeatedly takes intermediate values for each line segment to create a new line segments that will eventually lead to a nice curve. I implemented it by first checking if the number of points is greater than 1 (if it's 1 then return the points vector). Then I used a for loop to generate each pi' (p1' to pn-1') using the formula in the spec.</p>
		
		<p><b> Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press E to step through. Toggle C to show the completed Bezier curve as well. </b></p>
		<p> step 1 </p>
		<img src="./task 1 - step 1.png">
		
		<p> step 2 </p>
		<img src="./task 1 - step 2.png">
		
		<p> step 3 </p>
		<img src="./task 1 - step 3.png">
		
		<p> step 4 </p>
		<img src="./task 1 - step 4.png">
		
		<p> step 5 </p>
		<img src="./task 1 - step 5.png">
		
		<p> final curve </p>
		<img src="./task 1 - final curve.png">
		
		<p><b> Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter t via mouse scrolling. </b></p>
		<img src="./task 1 - diff curve.png">
		
		<!-- ##################TASK 2##################-->
		<h2> Task 2 </h2>
		
		<p><b> Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces. </b></p>
		<p> We can apply de Casteljau algorithm on bezier surfaces multiple times to extend it. By applying the algorithm to each row of points, we can combine them to do the algorithm in the other direction and finally evaluate the point that we want. In terms of implementing it, evaluateStep is the same as task one but modified to have 3d vectors instead of 2d vectors. Evaluate1D recursively evaluates the next level by calling evaluateStep and then Evaluate1D on that result until the number of points is equal to 1. Evaluate takes each row in controlPoints and evaluates them using evaluate1D and u as t. Then once each row is evaluated we evaluate each result one last time with evaluate1D but with v this time.</p>
		
		<p><b> Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation. </b></p>
		<p> Test Answer </p>
		
		<!-- ##################TASK 3##################-->
		
		<h2> Task 3 </h2>
		
		<p><b> Briefly explain how you implemented the area-weighted vertex normals. </b></p>
		<p> Test Answer </p>
		
		<p><b> Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use Q to toggle default flat shading and Phong shading. </b></p>
		<p> Test Answer </p>
		
		<!-- ##################TASK 4##################-->
		
		<h2> Task 4 </h2>
		<p><b> Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used. </b></p>
		<p> Test Answer </p>
		
		
		<p><b> Show screenshots of a mesh before and after some edge flips. </b></p>
		<p> Test Answer </p>
		
		<p><b> Write about your eventful debugging journey, if you have experienced one. </b></p>
		<p> Test Answer </p>
		
		<!-- ##################TASK 5##################-->
		
		<h2> Task 5 </h2>
		
		<p><b> Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used. </b></p>
		<p> Test Answer </p>
		
		<p><b> Show screenshots of a mesh before and after some edge splits. </b></p>
		<p> Test Answer </p>
		
		<p><b> Show screenshots of a mesh before and after a combination of both edge splits and edge flips. </b></p>
		<p> Test Answer </p>
		
		<p><b> Write about your eventful debugging journey, if you have experienced one. </b></p>
		<p> Test Answer </p>
		
		<p><b> If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges. </b></p>
		<p> Test Answer </p>
		
		
		<!-- ##################TASK 6##################-->
		
		<h2> Task 6 </h2>
		
		<p><b> Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used. </b></p>
		<p> Test Answer </p>
		
		<p><b> Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges? </b></p>
		<p> Test Answer </p>
		
		<p><b> Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects. </b></p>
		<p> Test Answer </p>
		
		
		
	</body>
</html>
